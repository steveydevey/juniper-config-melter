# Cursor Rules for Python Project Development

## Environment Setup Best Practices

### Virtual Environment Issues
- **ALWAYS** verify virtual environment integrity before proceeding
- If virtual environment creation fails with unusual errors (e.g., AppImage references), use system Python as fallback
- Check `which python` and `python -c "import sys; print(sys.executable)"` to verify correct interpreter
- When virtual environments are corrupted, prefer system Python installation over repeated venv attempts

### Dependency Management
- Install dependencies globally if virtual environment issues persist
- Use `pip3 install -r requirements.txt` for consistent dependency installation
- Always verify imports work before proceeding with development
- Test both API server and unit tests to ensure complete setup

## Testing Strategy

### Test Execution
- Use explicit Python interpreter: `python3 -m unittest tests/test_parser.py`
- Set PYTHONPATH when needed: `PYTHONPATH=$(pwd) python3 -m unittest tests/test_parser.py`
- Verify test imports work before running full test suites
- Test both individual components and integrated systems

### API Testing
- Test FastAPI endpoints with curl: `curl -v http://127.0.0.1:PORT/endpoint`
- Use different ports to avoid conflicts: 8001, 8002, 8003, etc.
- Verify HTTP status codes and response content
- Test health endpoints first to confirm server startup

## Project Structure Guidelines

### Package Organization
- Create `__init__.py` files in all package directories
- Use relative imports within packages: `from app.models.network import Network`
- Maintain clear separation between models, parsers, and API layers
- Follow the established directory structure from the plan

### Code Quality
- Implement stub methods with TODO comments for future development
- Use Pydantic models for data validation and serialization
- Create comprehensive test coverage for all components
- Document setup and testing procedures in README.md

## Development Workflow

### Phase-Based Development
- Complete and test each phase before proceeding
- Verify all components work together before moving to next phase
- Document lessons learned and update rules accordingly
- Maintain working state at end of each phase

### Error Handling
- When encountering persistent environment issues, adapt approach rather than repeating failed methods
- Use system tools when virtual environments are problematic
- Document workarounds and alternative approaches
- Focus on functionality over perfect environment setup

## Communication Guidelines

- Clearly explain technical decisions and trade-offs
- Provide specific commands and expected outputs
- Ask for user preferences when multiple approaches are viable
- Summarize completed work and next steps clearly

## Key Commands Reference

```bash
# Environment verification
which python && python --version
python -c "import sys; print(sys.executable)"

# Dependency installation
pip3 install -r requirements.txt

# Testing
python3 -m unittest tests/test_parser.py
PYTHONPATH=$(pwd) python3 -m unittest tests/test_parser.py

# API testing
python3 -m uvicorn app.main:app --port 8001
curl -v http://127.0.0.1:8001/health

# Project structure
mkdir -p app/{models,parsers,static/{css,js},templates} tests examples/sample_configs
```

## Success Criteria
- All tests pass with explicit Python interpreter
- API endpoints respond correctly to HTTP requests
- Project structure follows established patterns
- Dependencies are properly installed and importable
- Documentation is clear and actionable

# Cursor Rules for Juniper Config Melter Project

## Phase 2 Lessons Learned & Best Practices

### Juniper Configuration Parsing Patterns

#### Regex Strategy for Nested Configurations
- **Use `re.DOTALL` flag** for parsing multi-line configuration blocks
- **Pattern for interface blocks**: `r'(vlan|\w+-\d+/\d+/\d+)\s*\{([^}]+)\}'`
- **Handle nested family blocks**: `r'family\s+inet\s*\{[^}]*address\s+(\d+\.\d+\.\d+\.\d+/\d+);[^}]*\}'`
- **Extract descriptions**: `r'description\s+"([^"]+)";'`
- **Parse VLAN definitions**: `r'(\w+)\s*\{[^}]*description\s+"([^"]+)";[^}]*vlan-id\s+(\d+);[^}]*\}'`

#### Configuration Structure Insights
- Juniper configs use hierarchical block structure with `{` and `}`
- Interfaces can be physical (`ge-0/0/0`) or logical (`vlan`)
- IP addresses are nested within `family inet` blocks
- VLANs have both names and numeric IDs
- Static routes follow pattern: `route <destination> next-hop <gateway>;`

### Mermaid.js Generation Best Practices

#### Diagram Type Strategy
- **Topology diagrams**: Show physical connections, use `graph TD`
- **Routing diagrams**: Show logical paths, use `graph LR` for horizontal layout
- **VLAN diagrams**: Group by VLAN relationships
- **Interface diagrams**: Group by interface type (GE, XE, etc.)
- **Overview diagrams**: Include styling classes for visual appeal

#### Node ID Sanitization
```python
def _sanitize_id(self, text: str) -> str:
    # Remove special characters and replace with underscores
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', text)
    # Ensure it starts with a letter
    if sanitized and not sanitized[0].isalpha():
        sanitized = f"node_{sanitized}"
    return sanitized if sanitized else "node"
```

#### Styling Classes for Visual Appeal
```mermaid
classDef device fill:#e1f5fe,stroke:#01579b,stroke-width:2px
classDef interface fill:#f3e5f5,stroke:#4a148c,stroke-width:1px
classDef vlan fill:#e8f5e8,stroke:#1b5e20,stroke-width:1px
classDef route fill:#fff3e0,stroke:#e65100,stroke-width:1px
```

### Data Model Design Patterns

#### Pydantic Model Structure
- **Core models** in `app/models/network.py` for generic network concepts
- **Vendor-specific models** in `app/models/juniper.py` for Juniper-specific elements
- **Use Optional fields** for elements that may not be present
- **Include validation** through Pydantic's built-in type checking

#### Model Relationships
```python
# Network contains Devices
class Network(BaseModel):
    devices: List[Device]
    connections: Optional[List[dict]] = None

# Device contains Interfaces and Routing info
class Device(BaseModel):
    hostname: str
    interfaces: List[Interface]
    routing: Optional[dict] = None

# Vendor-specific models for detailed parsing
class VLAN(BaseModel):
    name: str
    vlan_id: int
    description: Optional[str] = None
```

### Testing Strategy for Parsers

#### Test Structure
- **Load real configuration files** for realistic testing
- **Test individual parsing methods** before full integration
- **Verify extracted data accuracy** with known values
- **Test edge cases** (missing descriptions, no IP addresses, etc.)

#### Test Patterns
```python
def setUp(self):
    # Load test configuration once
    config_path = os.path.join(os.path.dirname(__file__), '..', 'test-configs', 'ex3300-1.conf')
    with open(config_path, 'r') as f:
        self.config_text = f.read()

def test_specific_elements(self):
    # Test specific known values
    hostname = self.parser._extract_hostname(self.config_text)
    self.assertEqual(hostname, "ex3300")
```

### Performance Optimization Insights

#### Parsing Efficiency
- **Use `re.finditer()`** for multiple matches instead of `re.findall()`
- **Compile regex patterns** if used repeatedly
- **Process in single pass** when possible to avoid multiple file reads
- **Limit interface display** in overview diagrams (e.g., first 5 interfaces)

#### Memory Management
- **Parse incrementally** for large configuration files
- **Use generators** for large datasets
- **Clean up temporary variables** in parsing loops

### Error Handling Patterns

#### Graceful Degradation
- **Return empty lists** instead of None for missing elements
- **Use default values** for optional fields
- **Continue parsing** even if individual elements fail
- **Log parsing errors** for debugging without stopping execution

#### Validation Strategy
```python
# Extract with fallback
hostname_match = re.search(r'host-name\s+(\S+);', config_text)
return hostname_match.group(1) if hostname_match else "unknown"

# Safe list operations
for interface in device.interfaces[:5]:  # Limit to prevent overflow
    # Process interface
```

### Project Structure Lessons

#### Module Organization
- **Separate concerns**: Parsers, models, generators in different modules
- **Clear imports**: Use relative imports within packages
- **Consistent naming**: Follow established patterns (e.g., `juniper_parser.py`)
- **Documentation**: Include docstrings for all public methods

#### File Organization
```
app/
├── models/          # Data structures
├── parsers/         # Parsing logic
├── static/          # Web assets (future)
└── templates/       # HTML templates (future)
```

### Development Workflow Insights

#### Iterative Development
- **Start with simple regex patterns** and refine based on test results
- **Test with real data** early and often
- **Build incrementally** - parse one element type at a time
- **Validate output** visually by examining generated diagrams

#### Debugging Strategies
- **Print intermediate results** during development
- **Use demo scripts** to showcase functionality
- **Save generated output** to files for inspection
- **Test with multiple configuration types** to ensure robustness

### Future Development Considerations

#### Extensibility Patterns
- **Plugin architecture** for different diagram types
- **Configuration-driven** parsing rules
- **Template system** for diagram generation
- **API-first design** for web interface integration

#### Scalability Planning
- **Support for multiple devices** in single network
- **Caching parsed results** for large configurations
- **Background processing** for complex diagrams
- **Export formats** beyond Mermaid.js

## Phase 3 Lessons Learned & Best Practices

### FastAPI Development Patterns

#### Application Structure
- **Initialize parsers globally** to avoid repeated instantiation
- **Use dependency injection** for shared resources
- **Mount static files** for web assets: `app.mount("/static", StaticFiles(directory="app/static"))`
- **Template rendering** with Jinja2: `templates = Jinja2Templates(directory="app/templates")`

#### File Upload Handling
```python
@app.post("/upload")
async def upload_config(file: UploadFile = File(...)):
    # Validate file type
    if not file.filename.endswith(('.conf', '.txt')):
        raise HTTPException(status_code=400, detail="Invalid file type")
    
    # Read and decode content
    content = await file.read()
    config_text = content.decode('utf-8')
    
    # Process and return results
    return {"config_id": config_id, "filename": file.filename}
```

#### Error Handling Strategy
- **Use HTTPException** for proper HTTP status codes
- **Provide meaningful error messages** for debugging
- **Handle file encoding issues** gracefully
- **Validate input** before processing

### Frontend-Backend Integration

#### JavaScript API Patterns
```javascript
// File upload with FormData
const formData = new FormData();
formData.append('file', file);
const response = await fetch('/upload', {
    method: 'POST',
    body: formData
});

// Error handling
if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Upload failed');
}
```

#### Mermaid.js Integration
```javascript
// Initialize Mermaid
mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    flowchart: {
        useMaxWidth: true,
        htmlLabels: true
    }
});

// Render diagram
const mermaidDiv = document.createElement('div');
mermaidDiv.className = 'mermaid';
mermaidDiv.textContent = mermaidCode;
mermaid.init(undefined, mermaidDiv);
```

### Web Interface Design Patterns

#### Bootstrap Integration
- **Responsive grid system** for mobile/desktop compatibility
- **Card-based layout** for clean organization
- **Button groups** for diagram type selection
- **Modal dialogs** for loading states

#### User Experience Considerations
- **Loading indicators** during file processing
- **Success/error notifications** with auto-dismiss
- **Configuration list** for managing multiple uploads
- **Real-time diagram switching** without page reload

### Data Management Patterns

#### In-Memory Storage (Demo)
```python
# Simple in-memory storage for demo
config_storage: Dict[str, dict] = {}

# Store configuration with unique ID
config_id = str(uuid.uuid4())
config_storage[config_id] = {
    "filename": file.filename,
    "network": network.dict(),
    "diagrams": diagrams,
    "timestamp": "2024-01-01T00:00:00Z"
}
```

#### Production Considerations
- **Database storage** for persistent configurations
- **File system storage** for large configurations
- **Caching strategies** for frequently accessed diagrams
- **User authentication** for multi-user support

### API Design Best Practices

#### RESTful Endpoints
- `GET /` - Main web interface
- `GET /health` - Health check
- `POST /upload` - File upload and processing
- `GET /parse/{config_id}` - Get parsed data
- `GET /diagram/{config_id}` - Get specific diagram
- `GET /configs` - List configurations
- `DELETE /config/{config_id}` - Delete configuration

#### Response Format Consistency
```python
# Success response
return {
    "config_id": config_id,
    "filename": filename,
    "device_count": len(network.devices),
    "interface_count": interface_count,
    "vlan_count": vlan_count
}

# Error response
raise HTTPException(status_code=404, detail="Configuration not found")
```

### Testing Web Interfaces

#### API Testing Strategy
```python
# Test health endpoint
response = requests.get(f"{base_url}/health")
assert response.status_code == 200
assert response.json()["status"] == "healthy"

# Test file upload
with open("test-configs/ex3300-1.conf", "rb") as f:
    files = {"file": ("ex3300-1.conf", f, "text/plain")}
    response = requests.post(f"{base_url}/upload", files=files)
assert response.status_code == 200
```

#### Frontend Testing Considerations
- **Cross-browser compatibility** testing
- **Mobile responsiveness** validation
- **File upload edge cases** (large files, invalid formats)
- **Diagram rendering** in different browsers

### Performance Optimization

#### Backend Optimization
- **Async file processing** for large configurations
- **Caching parsed results** to avoid re-parsing
- **Compression** for large diagram responses
- **Background processing** for complex diagrams

#### Frontend Optimization
- **Lazy loading** of diagrams
- **Debounced search** for configuration lists
- **Image optimization** for diagram exports
- **Progressive enhancement** for older browsers

## Key Success Factors from Phase 3

1. **API-First Design**: RESTful endpoints enabled easy frontend integration
2. **Real-time Feedback**: Loading states and progress indicators improved UX
3. **Error Handling**: Comprehensive error handling prevented crashes
4. **Responsive Design**: Bootstrap ensured mobile compatibility
5. **Modular Architecture**: Separated concerns between frontend and backend

## Common Pitfalls to Avoid

1. **Synchronous file processing**: Use async/await for file operations
2. **Missing error handling**: Always handle file upload errors
3. **Poor UX feedback**: Provide loading states and success/error messages
4. **Hard-coded paths**: Use relative paths for static files
5. **Insufficient validation**: Validate file types and content before processing

## Key Success Factors from Phase 2

1. **Realistic Testing**: Using actual Juniper configurations revealed edge cases
2. **Incremental Development**: Building parser components separately before integration
3. **Visual Validation**: Generated diagrams provided immediate feedback on parsing accuracy
4. **Comprehensive Models**: Pydantic models ensured data consistency and validation
5. **Modular Design**: Separating parser and generator allowed independent testing and development

## Common Pitfalls to Avoid

1. **Over-complex regex**: Start simple and add complexity as needed
2. **Hard-coded assumptions**: Test with various configuration formats
3. **Missing error handling**: Always provide fallbacks for missing data
4. **Performance neglect**: Consider parsing efficiency for large files
5. **Insufficient testing**: Test with real-world data, not just examples 